/***********************************************************************
 * The rDock program was developed from 1998 - 2006 by the software team
 * at RiboTargets (subsequently Vernalis (R&D) Ltd).
 * In 2006, the software was licensed to the University of York for
 * maintenance and distribution.
 * In 2012, Vernalis and the University of York agreed to release the
 * program as Open Source software.
 * This version is licensed under GNU-LGPL version 3.0 with support from
 * the University of Barcelona.
 * http://rdock.sourceforge.net/
 ***********************************************************************/

#include "Model.h"
#include "AtomFuncs.h"
#include "BaseMolecularFileSource.h"
#include "ChromElement.h"
#include "ChromFactory.h"
#include "FlexData.h"
#include "ModelError.h"
#include "Quat.h"
#include <functional>
#include <iomanip>

using namespace rxdock;

Model::Model(BaseMolecularFileSource *pMolSource)
    : m_occupancy(1.0), m_enabled(true) {
  Create(pMolSource);
  _RBTOBJECTCOUNTER_CONSTR_("Model");
}

//(Fairly) temporary constructor taking arbitrary atom and bond lists
// Use with caution
Model::Model(AtomList &atomList, BondList &bondList)
    : m_pFlexData(nullptr), m_pChrom(nullptr), m_occupancy(1.0),
      m_enabled(true) {
  AddAtoms(atomList); // Register atoms with model
  m_bondList = bondList;
  // FindRings(m_atomList,m_bondList,m_ringList);

  // DM 8 Feb 1999 Add the unnamed coord to the coord map
  m_coordNames[""] = 0;
  // DM 15 June 2006. Define the model name as the fully qualified
  // name of the first atom (mainly used for solvent)
  if (!atomList.empty()) {
    m_strName = (atomList.front())->GetFullAtomName();
  }
  _RBTOBJECTCOUNTER_CONSTR_("Model");
}

// Default destructor
Model::~Model() {
#ifdef _DEBUG
  std::cout << "~Model: deleting " << m_strName << " (" << m_atomList.size()
            << " atoms, " << m_bondList.size() << " bonds)" << std::endl;
#endif     //_DEBUG
  Clear(); // clear the current model
  _RBTOBJECTCOUNTER_DESTR_("Model");
}

//////////////////////
// Public methods
//////////////////////

// DM 12 May 1999 - support for associated model data (e.g. SD file, or
// generated by rbdock etc) Get list of field names as string list
std::vector<std::string> Model::GetDataFieldList() const {
  std::vector<std::string> dataFieldList;
  dataFieldList.reserve(m_dataMap.size());
  for (StringVariantMapConstIter iter = m_dataMap.begin();
       iter != m_dataMap.end(); iter++)
    dataFieldList.push_back((*iter).first);
  return dataFieldList;
}

// Query as to whether a particular data field name is present
bool Model::isDataFieldPresent(const std::string &strDataField) const {
  return m_dataMap.find(strDataField) != m_dataMap.end();
}

// Get a particular data value
// Note: unlike the MolecularFileSource method, the Model version
// doesn't throw an error if the field name is not found.
// Instead, an empty variant is returned.
Variant Model::GetDataValue(const std::string &strDataField) const {
  StringVariantMapConstIter iter = m_dataMap.find(strDataField);
  if (iter != m_dataMap.end())
    return (*iter).second;
  else
    return Variant();
}

// Set a data value (replaces existing value if field name already exists)
void Model::SetDataValue(const std::string &strDataField,
                         const Variant &dataValue) {
  m_dataMap[strDataField] = dataValue;
}

// Removes a data field completely from the data map
void Model::ClearDataField(const std::string &strDataField) {
  m_dataMap.erase(strDataField);
}

// Removes all data fields starting with a given prefix from the data map
void Model::ClearAllDataFields(const std::string &strDataFieldPrefix) {
  std::vector<std::string> dataFields = GetDataFieldList();
  for (std::vector<std::string>::const_iterator iter = dataFields.begin();
       iter != dataFields.end(); iter++) {
    if ((*iter).find(strDataFieldPrefix) == 0)
      ClearDataField(*iter);
  }
}

// Removes all data fields from the data map
void Model::ClearAllDataFields() { m_dataMap.clear(); }

// DM 11 Jul 2000 - pseudoatom handling
// DM 17 Oct 2001 - now checks for whether pseudo atom has previously been
// created If so, returns the original pseudo atom pointer (does not create a
// new one) Reduces overhead of updating pseudo atom coordinates for flexible
// molecules Argument list has changed from PseudoAtomPtr to const
// AtomList& i.e. pseudo atom is created inside the method, and
// PseudoAtomPtr returned
PseudoAtomPtr Model::AddPseudoAtom(const AtomList &atomList) {
  // std::cout << "AddPseudoAtom";
  // for (AtomListConstIter iter = atomList.begin(); iter != atomList.end();
  // iter++) {
  //  std::cout << "\t" << (*iter)->GetFullAtomName();
  //}
  // std::cout << std::endl;
  // Check if we have this pseudo atom already
  for (PseudoAtomListConstIter pIter = m_pseudoAtomList.begin();
       pIter != m_pseudoAtomList.end(); pIter++) {
    // std::cout << "Checking pseudo atom #" << (*pIter)->GetAtomId() << "\t" <<
    // (*pIter)->GetNumAtoms() << " atoms" << std::endl;
    AtomList atomList2 = (*pIter)->GetAtomList();
    if (atomList.size() != atomList2.size()) {
      // std::cout << "No match: Unequal number of atoms" << std::endl;
      continue;
    }
    bool bMatch = true;
    for (AtomListConstIter aIter = atomList2.begin();
         aIter != atomList2.end() && bMatch; aIter++) {
      // std::cout << "Checking " << (*aIter)->GetFullAtomName() << std::endl;
      bMatch = (GetNumAtomsWithPredicate(
                    atomList, std::bind(isAtomPtr_eq(), std::placeholders::_1,
                                        *aIter)) == 1);
    }
    if (bMatch) {
      // std::cout << "Match found" << std::endl;
      return (*pIter);
    }
  }
  int nPseudoAtomId = -1 - m_pseudoAtomList.size();
  PseudoAtomPtr spPseudoAtom(new PseudoAtom(atomList, nPseudoAtomId));
  m_pseudoAtomList.push_back(spPseudoAtom);
  // std::cout << "No match: creating new pseudo atom #" << nPseudoAtomId <<
  // std::endl;
  return spPseudoAtom;
}

void Model::ClearPseudoAtoms() { m_pseudoAtomList.clear(); }

// Updates pseudoatom coords
void Model::UpdatePseudoAtoms() {
  for (PseudoAtomListIter iter = m_pseudoAtomList.begin();
       iter != m_pseudoAtomList.end(); iter++) {
    (*iter)->UpdateCoords();
  }
}

unsigned int Model::GetNumPseudoAtoms() const {
  return m_pseudoAtomList.size();
}
PseudoAtomList Model::GetPseudoAtomList() const { return m_pseudoAtomList; }

// DM 1 Jul 2002 - tethered atom handling
unsigned int Model::GetNumTetheredAtoms() const {
  return GetTetheredAtomList().size();
}

// Parses the ">  <TETHERED ATOMS>" data field
//(comma-separated list of atom IDs)
// and returns an atomlist of tethered atoms in the same order
AtomList Model::GetTetheredAtomList() const {
  AtomList tetheredAtomList;
  // Can be multi-line so process as a vector of strings
  // (std::vector<std::string>)
  std::vector<std::string> dataField = GetDataValue("TETHERED ATOMS");
  for (std::vector<std::string>::const_iterator iter = dataField.begin();
       iter != dataField.end(); iter++) {
    // Each line is comma-separated list of atom IDs
    std::vector<std::string> strTetheredAtoms =
        ConvertDelimitedStringToList(*iter);
    for (std::vector<std::string>::const_iterator iter2 =
             strTetheredAtoms.begin();
         iter2 != strTetheredAtoms.end(); iter2++) {
      // Remember to subtract 1 from atom ID to convert to atom list index
      unsigned int i = std::atoi((*iter2).c_str()) - 1;
      if (i < m_atomList.size()) {
        tetheredAtomList.push_back(m_atomList[i]);
      } else {
        throw ModelError(_WHERE_,
                         "Tethered atom ID out of range (" + (*iter) + ")");
      }
    }
  }
  return tetheredAtomList;
}

void Model::SetOccupancy(double occupancy, double threshold) {
  m_occupancy = occupancy;
  m_enabled = occupancy >= threshold;
}

// Update coords from a data source
void Model::UpdateCoords(BaseMolecularFileSource *pMolSource) {
  try {
    // Read coord atom list
    // DM 16 Feb 2000 - attempt to match atom names in the source with those
    // already in the model Allows updating the coords of an implicit-hydrogen
    // model from an all-atom CRD file for e.g. AtomList
    // crdAtomList(GetMatchingAtomList(pMolSource->GetAtomList(),m_atomList));

    // DM 31 Oct 2000 - GetMatchingAtomList is too slow for large files
    // Make the assumption that atoms in the CRD file will be in the same order
    // as the PSF, but that there may be gaps
    AtomList crdAtomList(pMolSource->GetAtomList());

    // Copy coords from crd file to model
    // NOTE: no checking of matching atom types at present
    AtomListIter modelIter = m_atomList.begin();
    AtomListIter crdIter = crdAtomList.begin();
    isAtom_eq bIsAtomEq;

    // DM 30/11/98 Recompute the segment map in case the segment names in the
    // CRD file are different
    m_segmentMap.clear();
    int nUpdated(0);
    while (modelIter != m_atomList.end()) {
      // DM 31 Oct 2000 - hunt for next matching atom in CRD file
      // std::cout << "Comparing (CRD) " << (*crdIter)->GetFullAtomName() << "
      // with (MODEL) " << (*modelIter)->GetFullAtomName() << std::endl;
      while (!bIsAtomEq(*modelIter, *crdIter)) {
        //#ifdef _DEBUG
        std::cout << (*crdIter)->GetFullAtomName() << " does not match "
                  << (*modelIter)->GetFullAtomName() << std::endl;
        //#endif //_DEBUG
        crdIter++;
      }
      (*modelIter)->SetCoords((*crdIter)->GetCoords());
      (*modelIter)->SetSegmentName((*crdIter)->GetSegmentName());
      m_segmentMap[(*modelIter)->GetSegmentName()]++; // Increment the segment
                                                      // map atom counter
      modelIter++;
      crdIter++;
      nUpdated++;
    }
    UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                         // hand

    // DM 1/12/98 Update the model name to reflect the coordinate file name
    m_strName =
        pMolSource->GetFileName(); // Filename will do as a model name for now
    // Add list of segment names in segment filter to model name
    if (pMolSource->isSegmentFilterMapDefined()) {
      SegmentMap segmentFilterMap = pMolSource->GetSegmentFilterMap();
      m_strName += "::";
      m_strName += ConvertSegmentMapToString(segmentFilterMap);
    }
    // std::cout << "Model::UpdateCoords: " << nUpdated << " atoms in " <<
    // pMolSource->GetFileName()
    // << " found that match atoms in model" << std::endl;
  }

  catch (Error &error) {
    // Clear();//Clear the model so we don't leave incomplete data structures
    // hanging around
    pMolSource->Reset(); // Reset the source as we don't know what state we've
                         // left it in
    throw;               // Rethrow the Error
  }
}

// DM 07 Jan 1999
// Translate molecule by the given vector
void Model::Translate(const Vector &vector) {
  TranslateAtoms(m_atomList, vector);
  UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                       // hand
}

// Rotate molecule around the given axis (through the center of mass) by theta
// degrees DM 09 Feb 1999 - Rotate now calls generic Rotate method
void Model::Rotate(const Vector &axis, double thetaDeg) {
  Rotate(axis, thetaDeg, GetCenterOfMass());
  UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                       // hand
}

// DM 09 Feb 1999
// Rotate molecule around the given axis (through the given coordinate) by theta
// degrees
void Model::Rotate(const Vector &axis, double thetaDeg, const Coord &center) {
  // Translate all atoms so that the center of rotation lies at the origin
  TranslateAtoms(m_atomList, -center);
  // Apply a rotation through theta degrees to all atoms
  Quat quat(axis, thetaDeg * M_PI / 180.0);
  RotateAtomsUsingQuat(m_atomList, quat);
  // Translate all atoms back again so that the center of rotation is back where
  // it started
  TranslateAtoms(m_atomList, center);
  UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                       // hand
}

// Rotate around a given bond by theta degrees, keeping the center of mass
// invariant
void Model::RotateBond(BondPtr spBond, double thetaDeg) {
  AtomPtr spAtom1 = spBond->GetAtom1Ptr();
  AtomPtr spAtom2 = spBond->GetAtom2Ptr();

  // Check if both atoms are actually in the model
  if ((spAtom1->GetModelPtr() != this) || (spAtom2->GetModelPtr() != this))
    return;

  // Store the center of mass
  Coord com(GetCenterOfMass());

  // Coords of atom 1
  Coord coord1(spAtom1->GetCoords());
  // Vector along the bond between atom 1 and atom 2 (rotation axis, doesn't
  // have to be unit length)
  Vector bondVector(spAtom2->GetCoords() - coord1);

  // Translate all atoms so that atom 1 lies at the origin
  TranslateAtoms(m_atomList, -coord1);

  // Select the atoms on one side of the bond
  // DM 30 Oct 2000 - call standalone version of ToSpin
  ToSpin(spBond, m_atomList, m_bondList);

  // Apply a rotation through theta/2 to the selected atoms
  Quat quat(bondVector, 0.5 * thetaDeg * M_PI / 180.0);
  RotateSelectedAtomsUsingQuat(m_atomList, quat);

  // Invert the atom selection so that atoms on the other end of the bond are
  // selected
  InvertAtomSelectionFlags(m_atomList);
  spAtom1->SetSelectionFlag(false);
  spAtom2->SetSelectionFlag(false);
  bondVector = -bondVector;

  // Apply a rotation through -theta/2 to the selected atoms
  quat = Quat(bondVector, 0.5 * thetaDeg * M_PI / 180.0);
  RotateSelectedAtomsUsingQuat(m_atomList, quat);

  // Finally, translate the atoms back so that the center of mass is where it
  // started
  TranslateAtoms(m_atomList, com - GetCenterOfMass());
  UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                       // hand
}

// Rotate around a given bond by theta degrees, keeping the given atom fixed
// (only spins the other end of the bond)
void Model::RotateBond(BondPtr spBond, double thetaDeg, AtomPtr spFixedAtom) {
  AtomPtr spAtom1 = spBond->GetAtom1Ptr();
  AtomPtr spAtom2 = spBond->GetAtom2Ptr();

  // Check if both atoms in the bond and the fixed atom are actually in the
  // model
  if ((spAtom1->GetModelPtr() != this) || (spAtom2->GetModelPtr() != this) ||
      (spFixedAtom->GetModelPtr() != this))
    return;

  // Coords of atom 1
  Coord coord1(spAtom1->GetCoords());
  // Vector along the bond between atom 1 and atom 2 (rotation axis, doesn't
  // have to be unit length)
  Vector bondVector(spAtom2->GetCoords() - coord1);

  // Translate all atoms so that atom 1 lies at the origin
  TranslateAtoms(m_atomList, -coord1);

  // Select the atoms on one side of the bond
  // DM 30 Oct 2000 - call standalone version of ToSpin
  ToSpin(spBond, m_atomList, m_bondList);

  // If the fixed atom is selected for rotation then we need to invert the atom
  // selection so that the other end of the bond is spun instead
  if (spFixedAtom->GetSelectionFlag()) {
    InvertAtomSelectionFlags(m_atomList);
    spAtom1->SetSelectionFlag(false);
    spAtom2->SetSelectionFlag(false);
    bondVector =
        -bondVector; // DM 25 Feb 1999 - Need to invert bond vector as well
  }

  // Apply a rotation through theta to the selected atoms
  Quat quat(bondVector, thetaDeg * M_PI / 180.0);
  RotateSelectedAtomsUsingQuat(m_atomList, quat);

  // Finally, translate the atoms back so that atom 1 is back where it started
  TranslateAtoms(m_atomList, coord1);
  UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                       // hand
}

// DM 25 Feb 1999 - Rotate around a given bond by theta degrees, only spinning
// one end of the bond If bSwap is false, spins the end bonded to atom2 in the
// bond If bSwap is true, spins the end bonded to atom1 in the bond
void Model::RotateBond(BondPtr spBond, double thetaDeg, bool bSwap) {
  AtomPtr spAtom1 = spBond->GetAtom1Ptr();
  AtomPtr spAtom2 = spBond->GetAtom2Ptr();

  // Check if both atoms in the bond and the fixed atom are actually in the
  // model
  if ((spAtom1->GetModelPtr() != this) || (spAtom2->GetModelPtr() != this))
    return;

  // Coords of atom 1
  Coord coord1(spAtom1->GetCoords());
  // Vector along the bond between atom 1 and atom 2 (rotation axis, doesn't
  // have to be unit length)
  Vector bondVector(spAtom2->GetCoords() - coord1);

  // Translate all atoms so that atom 1 lies at the origin
  TranslateAtoms(m_atomList, -coord1);

  // Select the atoms on one side of the bond
  // DM 30 Oct 2000 - call standalone version of ToSpin
  ToSpin(spBond, m_atomList, m_bondList);

  // If bSwap is true then we need to invert the atom selection
  // so that the other end of the bond is spun instead
  if (bSwap) {
    InvertAtomSelectionFlags(m_atomList);
    spAtom1->SetSelectionFlag(false);
    spAtom2->SetSelectionFlag(false);
    bondVector = -bondVector;
  }

  // Apply a rotation through theta to the selected atoms
  Quat quat(bondVector, thetaDeg * M_PI / 180.0);
  RotateSelectedAtomsUsingQuat(m_atomList, quat);

  // Finally, translate the atoms back so that atom 1 is back where it started
  TranslateAtoms(m_atomList, coord1);
  UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                       // hand
}

void Model::SaveCoords(const std::string &coordName) {
  // Look up the coord name in the map
  std::map<std::string, int>::const_iterator iter =
      m_coordNames.find(coordName);
  if (iter != m_coordNames.end()) {
    // std::cout << "Saving coords under name=" << iter->first << ",index=" <<
    // iter->second << std::endl; If we find the name, reuse the existing index
    SaveAtomCoords(m_atomList, (*iter).second);
    m_currentCoord = (*iter).second;
  } else {
    // Add a new index to the map and save the coords using this index
    unsigned int newIdx = m_coordNames.size();
    m_coordNames[coordName] = newIdx;
    // std::cout << "Saving coords under name=" << coordName << ",new index=" <<
    // newIdx << std::endl;
    SaveAtomCoords(m_atomList, newIdx);
    m_currentCoord = newIdx;
  }
}

void Model::RevertCoords(const std::string &coordName) {
  // Look up the coord name in the map
  std::map<std::string, int>::const_iterator iter =
      m_coordNames.find(coordName);
  if (iter != m_coordNames.end()) {
    // If we find the name, revert the coords
    // std::cout << "Reverting coords under name=" << iter->first << ",index="
    // << iter->second << std::endl;
    RevertAtomCoords(m_atomList, (*iter).second);
    UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                         // hand
    m_currentCoord = (*iter).second;
  } else {
    // Coord name not found, don't try and revert the coords
    // std::cout << "Error reverting coords, name=" << coordName << " not found"
    // << std::endl;
    throw InvalidRequest(_WHERE_, "RevertCoords failed on model " + GetName() +
                                      " for coord name=" + coordName);
  }
}

void Model::RevertCoords(int i) {
  if (i != m_currentCoord) {
    // std::cout << "Model: Reverting to coords #" << i << std::endl;
    RevertAtomCoords(m_atomList, i);
    UpdatePseudoAtoms();
    m_currentCoord = i;
  }
}

// Returns center of mass of model
Coord Model::GetCenterOfMass() const {
  return GetCenterOfAtomicMass(m_atomList);
}

// DM 9 Nov 1999
// Returns total atomic mass (molecular weight) for the model
double Model::GetTotalMass() const { return GetTotalAtomicMass(m_atomList); }

// DM 14 Apr 1999 - principal axes methods
// Return principal axes and center of mass for the model
PrincipalAxes Model::GetPrincipalAxes() const {
  return GetPrincipalAxesOfAtoms(m_atomList);
}

// Aligns the principal axes of the model to lie along alignAxes
// If required (bAlignCOM=true), also aligns the center of mass with
// alignAxes.com Default is to align with X,Y,Z Cartesian axes centered at
// origin
void Model::AlignPrincipalAxes(const PrincipalAxes &alignAxes, bool bAlignCOM) {
  AlignPrincipalAxesOfAtoms(m_atomList, alignAxes, bAlignCOM);
  UpdatePseudoAtoms(); // DM 11 Jul 2000 - need to update pseudoatom coords by
                       // hand
}

// DM 19 Oct 2005 - new chromosome handling
void Model::SetFlexData(FlexData *pFlexData) {
  m_spMutator.SetNull();
  // Manual mem management
  // DM 12 June 2006 - check that we are not passing in
  // the same FlexData object before deleting the old one
  if (m_pFlexData && (m_pFlexData != pFlexData)) {
    delete m_pFlexData;
    m_pFlexData = nullptr;
  }
  if (m_pChrom) {
    delete m_pChrom;
    m_pChrom = nullptr;
  }
  m_pFlexData = pFlexData;
  if (m_pFlexData) {
    m_pFlexData->SetModel(this);
    ChromFactory chromFactory;
    m_pFlexData->Accept(chromFactory);
    m_pChrom = chromFactory.GetChrom();
    m_spMutator = chromFactory.GetModelMutator();
  }
}

FlexData *Model::GetFlexData() const { return m_pFlexData; }

// Returns a clone of the current chromosome for this model
// The caller has the responsibility for mem management of the clone
ChromElement *Model::GetChrom() const {
  return (m_pChrom) ? m_pChrom->clone() : nullptr;
}

bool Model::isFlexible() const { return !m_spMutator.Null(); }

const AtomRList &Model::GetFlexIntns(Atom *pAtom) const {
  if (isFlexible()) {
    // Check if atom is actually in the model
    if (pAtom->GetModelPtr() != this) {
      throw BadArgument(_WHERE_, "GetFlexIntns: " + pAtom->GetFullAtomName() +
                                     " is not in model " + GetName());
    }
    const AtomRListList &flexIntns(m_spMutator->GetFlexIntns());
    unsigned int id = pAtom->GetAtomId() - 1;
    // Assertion - check id is within range
    Assert<Assertion>(!MUT_CHECK || (id < flexIntns.size()));
    AtomRListListConstIter lIter = flexIntns.begin() + id;
    return *lIter;
  } else {
    throw InvalidRequest(_WHERE_, "GetFlexIntns invalid for rigid models");
  }
}
BondList Model::GetFlexBonds() const {
  if (isFlexible()) {
    return m_spMutator->GetFlexBonds();
  } else {
    throw InvalidRequest(_WHERE_, "GetFlexBonds invalid for rigid models");
  }
}

// Select all flexible interactions to the specified atom
void Model::SelectFlexAtoms(Atom *pAtom) {
  // First deselect all atoms in the model
  // std::for_each(m_atomList.begin(),m_atomList.end(),
  // SelectAtom(false));

  if (isFlexible()) {
    // Check if atom is actually in the model
    if (pAtom->GetModelPtr() != this) {
      return;
    }
    const AtomRListList &flexIntns(m_spMutator->GetFlexIntns());
    unsigned int id = pAtom->GetAtomId() - 1;
    // Assertion - check id is within range
    Assert<Assertion>(!MUT_CHECK || (id < flexIntns.size()));
    AtomRListListConstIter lIter = flexIntns.begin() + id;
    std::for_each((*lIter).begin(), (*lIter).end(), SelectAtom(true));
  }
}

// Selects all atoms that are rotated by at least one rotable bond
void Model::SelectFlexAtoms() {
  // First deselect all atoms in the model
  // std::for_each(m_atomList.begin(),m_atomList.end(),SelectAtom(false));
  if (isFlexible()) {
    const AtomRListList &flexAtoms(m_spMutator->GetFlexAtoms());
    // flexAtoms is a vector of the atom lists to rotate across each rotable
    // bond If we select all of these then we create the total list of all
    // flexible atoms
    for (AtomRListListConstIter iter1 = flexAtoms.begin();
         iter1 != flexAtoms.end(); iter1++) {
      std::for_each((*iter1).begin(), (*iter1).end(), SelectAtom(true));
    }
  }
}

////////////////////////////////////////////
// Atom list functions (provided for convenience, as user could just as well
// call the  functions with Model::GetAtomList)
// e.g. AtomList atomList =
// GetSelectedAtomList(spModel->GetAtomList); is equivalent to
// AtomList atomList = spModel->GetSelectedAtomList();
////////////////////////////////////////////

// Unary

// Generic template version of GetNumAtoms, passing in your own predicate
// template<class Predicate> UInt Model::GetNumAtoms(const Predicate&
// pred)
//{
//  return GetNumAtomsWithPredicate(m_atomList,pred);
//}

// Generic template version of GetAtomList, passing in your own predicate
// template<class Predicate> AtomList Model::GetAtomList(const Predicate&
// pred)
//{
//  return GetAtomListWithPredicate(m_atomList,pred);
//}

// Selected atoms
void Model::SetAtomSelectionFlags(bool bSelected) {
  SetAtomSelectionFlagsInList(m_atomList, bSelected);
}

unsigned int Model::GetNumSelectedAtoms() {
  return GetNumSelectedAtomsInList(m_atomList);
}

AtomList Model::GetSelectedAtomList() {
  return GetSelectedAtomsFromList(m_atomList);
}

// Cyclic atoms
void Model::SetAtomCyclicFlags(bool bCyclic) {
  SetAtomCyclicFlagsInList(m_atomList, bCyclic);
}

unsigned int Model::GetNumCyclicAtoms() {
  return GetNumCyclicAtomsInList(m_atomList);
}

AtomList Model::GetCyclicAtomList() {
  return GetCyclicAtomsFromList(m_atomList);
}

// DM 21 Jul 1999 User1 flag
void Model::SetAtomUser1Flags(bool bUser1) {
  for (AtomListIter iter = m_atomList.begin(); iter != m_atomList.end(); iter++)
    (*iter)->SetUser1Flag(bUser1);
}

// DM 29 Jan 2000 User1 value
void Model::SetAtomUser1Values(double dUser1) {
  for (AtomListIter iter = m_atomList.begin(); iter != m_atomList.end(); iter++)
    (*iter)->SetUser1Value(dUser1);
}

// DM 27 Jul 2000 User2 value
void Model::SetAtomUser2Values(double dUser2) {
  for (AtomListIter iter = m_atomList.begin(); iter != m_atomList.end(); iter++)
    (*iter)->SetUser2Value(dUser2);
}

// Hydrogen bond acceptor atoms
unsigned int Model::GetNumHBondAcceptorAtoms() {
  return GetNumHBondAcceptorAtomsInList(m_atomList);
}

AtomList Model::GetHBondAcceptorAtomList() {
  return GetHBondAcceptorAtomsFromList(m_atomList);
}

// Hydrogen bond donor atoms
unsigned int Model::GetNumHBondDonorAtoms() {
  return GetNumHBondDonorAtomsInList(m_atomList);
}

AtomList Model::GetHBondDonorAtomList() {
  return GetHBondDonorAtomsFromList(m_atomList);
}

//(Formally) charged atoms
unsigned int Model::GetNumChargedAtoms() {
  return GetNumChargedAtomsInList(m_atomList);
}

AtomList Model::GetChargedAtomList() {
  return GetChargedAtomsFromList(m_atomList);
}

// Planar atoms
unsigned int Model::GetNumPlanarAtoms() {
  return GetNumPlanarAtomsInList(m_atomList);
}

AtomList Model::GetPlanarAtomList() {
  return GetPlanarAtomsFromList(m_atomList);
}

// Binary

// Atoms with atomic no = nAtomicNo
unsigned int Model::GetNumAtomsWithAtomicNo(int nAtomicNo) {
  return GetNumAtomsWithAtomicNo_eq(m_atomList, nAtomicNo);
}

AtomList Model::GetAtomListWithAtomicNo(int nAtomicNo) {
  return GetAtomListWithAtomicNo_eq(m_atomList, nAtomicNo);
}

// Atoms with FFType = strFFType
unsigned int Model::GetNumAtomsWithFFType(std::string strFFType) {
  return GetNumAtomsWithFFType_eq(m_atomList, strFFType);
}

AtomList Model::GetAtomListWithFFType(std::string strFFType) {
  return GetAtomListWithFFType_eq(m_atomList, strFFType);
}

////////////////////////////////////////////
// Bond list functions (provided for convenience, as user could just as well
// call the  functions with Model::GetBondList)
// e.g. BondList bondList =
// GetSelectedBondList(spModel->GetBondList); is equivalent to
// BondList bondList = spModel->GetSelectedBondList();
////////////////////////////////////////////

// Unary

// Generic template version of GetNumBonds, passing in your own predicate
template <class Predicate>
unsigned int Model::GetNumBonds(const Predicate &pred) {
  return GetNumBondsWithPredicate(m_bondList, pred);
}
// Generic template version of GetBondList, passing in your own predicate
template <class Predicate> BondList Model::GetBondList(const Predicate &pred) {
  return GetBondListWithPredicate(m_bondList, pred);
}

// Selected bonds
void Model::SetBondSelectionFlags(bool bSelected) {
  SetBondSelectionFlagsInList(m_bondList, bSelected);
}

unsigned int Model::GetNumSelectedBonds() {
  return GetNumSelectedBondsInList(m_bondList);
}

BondList Model::GetSelectedBondList() {
  return GetSelectedBondsFromList(m_bondList);
}

// Cyclic bonds
void Model::SetBondCyclicFlags(bool bCyclic) {
  SetBondCyclicFlagsInList(m_bondList, bCyclic);
}

unsigned int Model::GetNumCyclicBonds() {
  return GetNumCyclicBondsInList(m_bondList);
}

BondList Model::GetCyclicBondList() {
  return GetCyclicBondsFromList(m_bondList);
}

// DM 10 Dec 1998 - at some point these functions should be implemented as
// generic  functions operating on arbitrary atom and bond lists

// D Morley, 8 Dec 1998 - modified to now call Atom::isHBondDonor (rather
// than Bond::isHBondDonor D Morley, 2 Dec 1998 - go back to the old way,
// it's more convenient to get all donors in the same list and separate them
// later void Model::GetHBondDonorLists(AtomList& donorList, AtomList&
// donorHList)
//{
// Clear the lists
//  donorList.clear();
//  donorHList.clear();

// DM 10 Dec 1998 - this returns the list of hydrogen-bonding hydrogen atoms
//  donorHList = Model::GetHBondDonorAtomList();

// Now traverse the hydrogen atom list to find the matching list of heavy atoms
//  for (AtomListIter donorHIter = donorHList.begin(); donorHIter !=
//  donorHList.end(); donorHIter++) {
// Get the bonded atom list for this atom (should be exactly one)
//    AtomList bondedAtomList =
//    GetBondedAtomList((*donorHIter)->GetBondMap());
//    donorList.push_back(bondedAtomList.front());//Push the heavy atom
//  }
//}

// Get min and max x,y,z coords
// DM 28 Jul 1999 - use new CoordList Min,Max functions. bInit is ignored
void Model::GetMinMaxCoords(Coord &minCoord, Coord &maxCoord,
                            bool bInit /*=true*/) {
  CoordList coordList = GetCoordList(m_atomList);
  minCoord = Min(coordList);
  maxCoord = Max(coordList);
}

// Get map of (key=force field atom type string, value=no. of occurrences)
std::map<std::string, int> Model::GetAtomTypeMap() {
  std::map<std::string, int> atomTypeMap;
  for (AtomListIter iter = m_atomList.begin(); iter != m_atomList.end(); iter++)
    atomTypeMap[(**iter).GetFFType()]++;
  return atomTypeMap;
}

// Get map of (key=force field bond type (atom type pair) string, value=no. of
// occurrences)
std::map<std::string, int> Model::GetBondTypeMap() {
  std::map<std::string, int> bondTypeMap;
  for (BondListIter iter = m_bondList.begin(); iter != m_bondList.end();
       iter++) {
    std::string atom1Type = (*iter)->GetAtom1Ptr()->GetFFType();
    std::string atom2Type = (*iter)->GetAtom2Ptr()->GetFFType();
    if (atom1Type > atom2Type)
      std::swap(atom1Type, atom2Type);
    std::string bondPair = atom1Type + " " + atom2Type;
    bondTypeMap[bondPair]++;
  }
  return bondTypeMap;
}

//////////////////////
// Private methods
//////////////////////

// Clear the current model
void Model::Clear() {
  m_strName = "";
  m_titleList.clear();

  // Set the parent model pointer to nullptr for each atom, before
  // clearing the atom list, in case someone has copies of the atom list
  AtomListIter iter;
  for (iter = m_atomList.begin(); iter != m_atomList.end(); iter++)
    (*iter)->SetModelPtr(nullptr);

  m_atomList.clear();
  m_bondList.clear();
  m_segmentMap.clear();
  // Clear each ring atom list in the list of lists
  // std::for_each(m_ringList.begin(),m_ringList.end(),std::mem_fn(&AtomList::clear));
  for (AtomListListIter liter = m_ringList.begin(); liter != m_ringList.end();
       liter++)
    (*liter).clear();
  m_ringList.clear();   // Now clear the list of lists
  m_coordNames.clear(); // Clear map of named coords
  m_dataMap.clear();    // DM 12 May 1999 - clear associated data
  ClearPseudoAtoms();
  SetFlexData(nullptr);
}

// Helper function for the constructor
// Create a new model from a data source
void Model::Create(BaseMolecularFileSource *pMolSource) {
  m_pFlexData = nullptr;
  m_pChrom = nullptr;
  Clear(); // Clear previous model, if any

  try {
    // Title list isn't exactly crucial so don't throw an error if
    // it's not supported by the source
    if (pMolSource->isTitleListSupported())
      m_titleList = pMolSource->GetTitleList();

    // Atom and bond lists are mandatory for creating a model
    // so allow an error to be thrown if not supported by the source
    AtomList atomList = pMolSource->GetAtomList();
    AddAtoms(atomList); // Register atoms with model
    m_bondList = pMolSource->GetBondList();
    m_strName =
        pMolSource->GetFileName(); // Filename will do as a model name for now
    // Add list of segment names in segment filter to model name
    if (pMolSource->isSegmentFilterMapDefined()) {
      SegmentMap segmentFilterMap = pMolSource->GetSegmentFilterMap();
      m_strName += "::";
      m_strName += ConvertSegmentMapToString(segmentFilterMap);
    }

    // DM 12 May 1999 Read any associated data if supported by the source
    // DM 18 May 1999 Set the model name to the SD Reg Number or Name field if
    // present
    if (pMolSource->isDataSupported()) {
      m_dataMap = pMolSource->GetDataMap();
      std::string strRegNum = GetDataValue("REG_Number");
      std::string strName = GetDataValue("Name");
      // In general, we want to use the Reg Number for the model name
      // except in the case of RBT compounds, where it's nice to keep the RBT
      // prefix
      if (!strRegNum.empty()) {
        // Case 1. Reg num defined, name begins with RBT => use name
        if (strName.substr(0, 3) == "RBT")
          m_strName = strName;
        // Case 2. Reg num defined, name does not begin with RBT => use reg num
        else
          m_strName = strRegNum;
      }
      // Case 3. Reg num undefined, name defined => use name
      else if (!strName.empty())
        m_strName = strName;
      // Case 4. Reg num undefined, name undefined => keep name = filename (null
      // op)
    }

    // We've registered some of the source's atoms as our own, so reset the
    // source This will force it to recreate the atom objects next time it is
    // used
    pMolSource->Reset();

    // 31 Oct 2000 (DM) Hack to disable ring detection
    // if $RBT_NORINGS is defined
    char *szNoRings = std::getenv("RBT_NORINGS");
    if (szNoRings == (char *)nullptr) {
      FindRings(m_atomList, m_bondList, m_ringList);
      // than set aromatic type for pi atoms. m_ringList is AtomListList
      for (AtomListListIter rIter = m_ringList.begin();
           rIter != m_ringList.end(); rIter++) {
        int nCy = (*rIter).size();
        // DM 19 Jun 2003 - more limited definition of AROM hybrid state
        // Specifically only used for 6-membered rings where all hybrid states
        // are initially SP2 DM 23 Oct 2003 - this does not work for fused
        // rings, where the 1st ring has already been assigned as AROM.
        // Subsequent fused rings were left as SP2 DM 07 Nov 2003 - looser
        // definition. Check for 6-membered rings that are all pi-atoms (SP2,
        // AROM or TRI). Change all SP2 atoms to AROM. This will change C_SP2
        // and N_SP2 to AROM, but will not change N_TRI. Will work with thymine,
        // which under the previous definition was not changed to AROM.
        int nPi = GetNumAtomsWithPredicate(*rIter, isPiAtom());
        if ((nCy == 6) && (nCy == nPi)) {
          for (AtomListIter aIter = (*rIter).begin(); aIter != (*rIter).end();
               aIter++) {
            if ((*aIter)->GetHybridState() == Atom::SP2) {
              (*aIter)->SetHybridState(Atom::AROM);
            }
          }
        }
      }
    }

    // DM 14 May 2002 - set the Tripos atom type property for each atom
    TriposAtomType triposType;
    for (AtomListIter iter = m_atomList.begin(); iter != m_atomList.end();
         iter++) {
      // only if it was not set yet
      if ((*iter)->GetTriposType() == TriposAtomType::UNDEFINED)
        (*iter)->SetTriposType(
            triposType(*iter, true)); // true = use extended types
    }

    // DM 8 Feb 1999 Add the unnamed coord to the coord map
    m_coordNames[""] = 0;
  }

  catch (Error &error) {
    Clear(); // Clear the model so we don't leave incomplete data structures
             // hanging around
    pMolSource->Reset(); // Reset the source as we don't know what state we've
                         // left it in
    throw;               // Rethrow the Error
  }
}

void Model::AddAtoms(AtomList &atomList) {
  for (AtomListIter iter = atomList.begin(); iter != atomList.end(); iter++) {
    // Tell the atom it belongs to this model
    (*iter)->SetModelPtr(this);
    // Add atom smart pointer to the model's atom list
    m_atomList.push_back(*iter);
    // Increment the segment map atom counter
    m_segmentMap[(*iter)->GetSegmentName()]++;
  }
}
